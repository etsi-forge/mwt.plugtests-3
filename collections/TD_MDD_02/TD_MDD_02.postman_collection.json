{
	"info": {
		"_postman_id": "e313331d-b162-49a3-af3f-f977e882dc92",
		"name": "TD_MDD_02",
		"description": "Interoperability Test Description\r\nTD_SDN_SNSD_02\r\nThe microwave topology information are requested from a single DC. The received information is compared to a template and checked for compliance.\r\nCFG_01\r\n\r\nMW_8040, MW_8345, MW_TETOPO, MW_MWTOPO\r\n\r\n•\tThe Domain Controller instance is up and running normally\r\n•\tAll the devices are upgraded to correct versions\r\n•\tAll basic configurations are completed (e.g., NE_id, OSPF, PCEP, etc.) \r\n•\tThe Restconf server is serviceable.\r\n\r\nStep\tType\tDescription\r\n1\tRequest\tSend GET request via Postman to one individual domain controller by executing Collection TD_SDN_SNSD_02 (see E.2.2)\r\n\r\n2\tValidation\tThe response body should contain information about the microwave topology in JSON format as specified in Annex D.\r\n",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "TD_MDD_02-Step-1",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "32ba873c-5587-4d73-98b3-a3f00d00c34d",
						"exec": [
							"// clear environment variables",
							"pm.environment.unset('TD_SDN_RESTCONF_PATH');",
							"pm.environment.unset('TD_SDN_MW_TOPOLOGY_PATH_SUFFIX');",
							"",
							"pm.test('Response is OK', function() {",
							"    pm.expect(pm.response).to.have.property('code', 200);",
							"});",
							"",
							"var responseJson = pm.response.json();",
							"var mw = {};",
							"",
							"",
							"function parseAllNetworks() {",
							"    var networksObj = null;",
							"    var networkList = {};",
							"    // The response body should contain information about the microwave topology and the Ethernet topology in the JSON format as specified in Annex D.1 and D.2.",
							"    pm.test('The response body should contain information about networks', function() {",
							"        var topLevelPropertyName = responseJson.hasOwnProperty('networks')",
							"            ? 'networks' : 'ietf-network:networks';",
							"        pm.expect(responseJson).to.have.property(topLevelPropertyName);",
							"        networksObj = responseJson[topLevelPropertyName];",
							"        pm.expect(networksObj).to.have.property('network');",
							"        networksObj.network.forEach(function(item, index) {",
							"            pm.expect(item).to.have.property('network-id');",
							"            pm.expect(networkList).to.not.have.property(item['network-id']); // Make sure each network-id appears only once",
							"            networkList[item['network-id']] = item;",
							"        });",
							"    });",
							"    ",
							"    mw = findMWNetwork(networksObj.network);",
							"    pm.test('Microwave topology is present', function() {",
							"        pm.expect(mw).to.not.equal(null);",
							"    });",
							"}",
							"",
							"function findMWNetwork(networks) {",
							"    var len = networks.length;",
							"    var i;",
							"    var net;",
							"    for (i = 0; i < len; ++i) {",
							"        net = networks[i];",
							"        if (net['network-types']",
							"                && net['network-types']['ietf-te-topology:te-topology']",
							"                && net['network-types']['ietf-te-topology:te-topology']['ietf-microwave-topology:mw-topology']) {",
							"            return net;        ",
							"        }",
							"    }",
							"    throw new Error('MicroWave network not found');",
							"}",
							"",
							"var settings = pm.environment.get('TD_SDN_SETTINGS');",
							"var tree = pm.environment.get('TD_SDN_TREE');",
							"var treeIndex = parseInt(tree) - 1;",
							"var companyName = settings.trees[treeIndex][pm.info.iteration];",
							"var companySettings = settings.companies[companyName];",
							"",
							"companySettings.mwLinkPoints = {};",
							"",
							"if (!companySettings.allNetworks) {",
							"    // We requested only one network. Check if it is the mw network",
							"    var topLevelPropertyName = responseJson.hasOwnProperty('network')",
							"            ? 'network' : 'ietf-network:networks';",
							"    pm.expect(responseJson).to.have.property(topLevelPropertyName);",
							"    mw = findMWNetwork(responseJson[topLevelPropertyName]);",
							"} else {",
							"    // We requested all networks. Find the mw network",
							"    parseAllNetworks();",
							"}",
							"",
							"// At this poing we are sure that mw variable is set",
							"",
							"function compare_tpid(a,b) {",
							"  if (a['tp-id'] < b['tp-id'])",
							"    return -1;",
							"  if (a['tp-id'] > b['tp-id'])",
							"    return 1;",
							"  return 0;",
							"}",
							"",
							"//   ------------------------- MICROWAVE ------------------------------",
							"pm.test('Microwave topology attributes verification', function() {",
							"    if (!companySettings.allNetworks) {",
							"        // check that found network-id is what it should",
							"        pm.expect(mw).to.have.property('network-id', companySettings.mwNetworkId);",
							"    } else {",
							"        pm.expect(mw).to.have.property('network-id');",
							"        // set mwNetworkId because it is need it in TD_SDN_SNDS_03",
							"        companySettings.mwNetworkId = mw['network-id'];",
							"        // we do not need another information. We can update variable",
							"        pm.environment.set('TD_SDN_SETTINGS', settings);",
							"    }",
							"    pm.expect(mw).to.have.property('network-types');",
							"    pm.expect(mw['network-types']).to.have.property('ietf-te-topology:te-topology');",
							"    pm.expect(mw['network-types']['ietf-te-topology:te-topology']).to.have.property('ietf-microwave-topology:mw-topology');",
							"",
							"    pm.expect(mw).to.have.property(\"ietf-te-topology:provider-id\"); //, provider_id);",
							"    pm.expect(mw).to.have.property(\"ietf-te-topology:client-id\"); //, client_id);",
							"    pm.expect(mw).to.have.property(\"ietf-te-topology:te-topology-id\"); //, mw_topology_id);",
							"    pm.expect(mw).to.have.property(\"ietf-te-topology:te\");",
							"    pm.expect(mw['ietf-te-topology:te']).to.have.property('name'); //, mw_network_name);",
							"});",
							"",
							"var nodeListMW = {};",
							"pm.test('Microwave topology nodes verification', function() {",
							"    pm.expect(mw).to.have.property('node');",
							"    mw.node.forEach(function(item, index) {",
							"        pm.expect(item).to.have.property('node-id');",
							"        pm.expect(nodeListMW).to.not.have.property(item['node-id']); // Make sure each node-id appears only once",
							"        nodeListMW[item['node-id']] = item;",
							"        var regExpStr = '^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.'",
							"                + '(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.'",
							"                + '(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.'",
							"                + '(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$';",
							"        var regExp = new RegExp(regExpStr);",
							"        pm.expect(regExp.test(item['node-id'])).to.be.true;",
							"        pm.expect(item).to.have.property('ietf-te-topology:te-node-id', item['node-id']);",
							"        pm.expect(item).to.have.property('ietf-te-topology:te');",
							"        pm.expect(item['ietf-te-topology:te']).to.have.property('te-node-attributes');",
							"        pm.expect(item['ietf-te-topology:te']['te-node-attributes']).to.have.property('name'); //vendor independent",
							"    });",
							"    pm.expect(Object.keys(nodeListMW).length).to.equal(2);",
							"});",
							"",
							"// Ensure nodeListMW have the full nodes information when the above verification partially fails, or the link verification will fail",
							"mw.node.forEach(function(item, index) {",
							"    if(mw.node != null){",
							"        nodeListMW[item['node-id']] = item;",
							"    }",
							"});",
							"",
							"pm.test('Microwave topology nodes OPER verification', function() {",
							"    for (var key in nodeListMW) {",
							"        pm.expect(nodeListMW[key]['ietf-te-topology:te']).to.have.property('oper-status', 'up');",
							"    }",
							"});",
							"",
							"pm.test('Microwave topology termination points verification', function() {",
							"    for (var key in nodeListMW) {",
							"        var node = nodeListMW[key];",
							"        pm.expect(node).to.have.property('ietf-network-topology:termination-point');",
							"        node.tp = {};",
							"        node['ietf-network-topology:termination-point'].sort(compare_tpid);",
							"        node['ietf-network-topology:termination-point'].forEach(function(tp, index) {",
							"            pm.expect(tp).to.have.property('tp-id'); // Vendor independent, only check existence",
							"            pm.expect(node.tp).to.not.have.property(tp['tp-id']); // Make sure each tp-id appears only once",
							"            node.tp[tp['tp-id']] = tp;",
							"            pm.expect(tp).to.have.property('ietf-te-topology:te-tp-id'); // Vendor independent, only check existence",
							"            pm.expect(tp).to.have.property('ietf-te-topology:te');",
							"            pm.expect(tp['ietf-te-topology:te']).to.have.property('admin-status', 'up');",
							"            pm.expect(tp['ietf-te-topology:te']).to.have.property('name');",
							"        });",
							"    }",
							"});",
							"",
							"// Ensure nodeListMW have the full tp information when the above verification partially fails, or the link verification will fail",
							"for (var key in nodeListMW) {",
							"    var node = nodeListMW[key];",
							"    node.tp = {};",
							"    node['ietf-network-topology:termination-point'].sort(compare_tpid);",
							"    node['ietf-network-topology:termination-point'].forEach(function(tp, index) {",
							"        node.tp[tp['tp-id']] = tp;",
							"    });",
							"}",
							"",
							"pm.test('Microwave topology termination points OPER verification', function() {",
							"    for (var key in nodeListMW) {",
							"        var node = nodeListMW[key];",
							"        pm.expect(node).to.have.property('ietf-network-topology:termination-point');",
							"        node['ietf-network-topology:termination-point'].forEach(function(tp, index) {",
							"            pm.expect(tp['ietf-te-topology:te']).to.have.property('oper-status', 'up');",
							"        });",
							"    }",
							"});",
							"",
							"var linkListMW = {};",
							"pm.test('Microwave topology links verification', function() {",
							"    var mwLinkPoints = [];",
							"    pm.expect(mw).to.have.property('ietf-network-topology:link');",
							"    mw['ietf-network-topology:link'].forEach(function(item, index) {",
							"        pm.expect(item).to.have.property('link-id');",
							"        pm.expect(linkListMW).to.not.have.property(item['link-id']); // Make sure each link-id appears only once",
							"        linkListMW[item['link-id']] = item;",
							"        pm.expect(item).to.have.property('source');",
							"        pm.expect(item.source).to.have.property('source-node');",
							"        pm.expect(item.source).to.have.property('source-tp');",
							"        pm.expect(nodeListMW).to.have.property(item.source['source-node']);",
							"        pm.expect(nodeListMW[item.source['source-node']].tp).to.have.property(item.source['source-tp']);",
							"        pm.expect(item).to.have.property('destination');",
							"        pm.expect(item.destination).to.have.property('dest-node');",
							"        pm.expect(item.destination).to.have.property('dest-tp');",
							"        pm.expect(nodeListMW).to.have.property(item.destination['dest-node']);",
							"        pm.expect(nodeListMW[item.destination['dest-node']].tp).to.have.property(item.destination['dest-tp']);",
							"        // Now we are sure that source-node,source-tp,dest-node,dest-tp exist, store",
							"        // the te-ids on companySettings param",
							"        var sourceNode = nodeListMW[item.source['source-node']];",
							"        var sourceTeNodeId = sourceNode['ietf-te-topology:te-node-id'];",
							"        var sourceTeTpId = sourceNode.tp[item.source['source-tp']]['ietf-te-topology:te-tp-id'];",
							"        var destNode = nodeListMW[item.destination['dest-node']];",
							"        var destTeNodeId = destNode['ietf-te-topology:te-node-id'];",
							"        var destTeTpId = destNode.tp[item.destination['dest-tp']]['ietf-te-topology:te-tp-id'];",
							"        mwLinkPoints.push([",
							"            {",
							"                \"te-node-id\": sourceTeNodeId,",
							"                \"te-tp-id\": sourceTeTpId",
							"            },",
							"            {",
							"                \"te-node-id\": destTeNodeId,",
							"                \"te-tp-id\": destTeTpId",
							"            },",
							"        ]);",
							"        pm.expect(item).to.have.property('ietf-te-topology:te');",
							"        pm.expect(item['ietf-te-topology:te']).to.have.property('te-link-attributes');",
							"",
							"        pm.expect(item['ietf-te-topology:te']['te-link-attributes']).to.have.property('admin-status', 'up');",
							"        pm.expect(item['ietf-te-topology:te']['te-link-attributes']).to.have.property('ietf-microwave-topology:mw-link-frequency');",
							"        pm.expect(item['ietf-te-topology:te']['te-link-attributes']).to.have.property('ietf-microwave-topology:mw-link-channel-separation');",
							"        // pm.expect(item['ietf-te-topology:te']['te-link-attributes']).to.have.property('ietf-microwave-topology:mw-link-availability');",
							"        // TODO - do we need to check anything with the availability? Likely not. Do we need this at all for now?",
							"    });",
							"    pm.expect(Object.keys(linkListMW).length).to.equal(2);",
							"    pm.expect(mwLinkPoints.length).to.equal(2);",
							"    pm.expect(mwLinkPoints[0][0][\"te-node-id\"]).to.equal(",
							"        mwLinkPoints[1][1][\"te-node-id\"]);",
							"    pm.expect(mwLinkPoints[0][0][\"te-tp-id\"]).to.equal(",
							"        mwLinkPoints[1][1][\"te-tp-id\"]);",
							"    pm.expect(mwLinkPoints[0][1][\"te-node-id\"]).to.equal(",
							"        mwLinkPoints[1][0][\"te-node-id\"]);",
							"    pm.expect(mwLinkPoints[0][1][\"te-tp-id\"]).to.equal(",
							"        mwLinkPoints[1][0][\"te-tp-id\"]);",
							"    companySettings.mwLinkPoints[mwLinkPoints[0][0][\"te-node-id\"]] = mwLinkPoints[0][0][\"te-tp-id\"];",
							"    companySettings.mwLinkPoints[mwLinkPoints[0][1][\"te-node-id\"]] = mwLinkPoints[0][1][\"te-tp-id\"];",
							"    pm.environment.set('TD_SDN_SETTINGS', settings);",
							"});",
							"",
							"pm.test('Microwave topology links OPER verification', function() {",
							"    for (var key in linkListMW) {",
							"        var link = linkListMW[key];",
							"        pm.expect(link).to.have.property('ietf-te-topology:te');",
							"        pm.expect(link['ietf-te-topology:te']).to.have.property(\"oper-status\", \"up\");",
							"        pm.expect(link['ietf-te-topology:te']).to.have.property('te-link-attributes');",
							"        pm.expect(link['ietf-te-topology:te']['te-link-attributes']).to.have.property('ietf-microwave-topology:mw-link-nominal-bandwidth');",
							"        pm.expect(link['ietf-te-topology:te']['te-link-attributes']).to.have.property('ietf-microwave-topology:mw-link-current-bandwidth');",
							"        pm.expect(link['ietf-te-topology:te']['te-link-attributes']).to.have.property('ietf-microwave-topology:mw-link-unreserved-bandwidth'); ",
							"    }",
							"});",
							""
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"id": "a48e32c4-0473-4b0f-866c-e005e5f57a79",
						"exec": [
							"pm.environment.unset('TD_SDN_RESTCONF_PATH');",
							"pm.environment.unset('TD_SDN_MW_TOPOLOGY_PATH_SUFFIX');",
							"",
							"if (pm.info.iterationCount !== 3) {",
							"    throw new Error('This collection MUST be run with 3 iterations; One for each domain of the tree');",
							"}",
							"",
							"var settings = pm.environment.get('TD_SDN_SETTINGS');",
							"if (settings === undefined) {",
							"    throw new Error('Environment variable \"TD_SDN_SETTINGS\" is undefined. '",
							"            + 'Please run \"Setup\" Request of \"TD_SDN_INIT\" collection.');",
							"}",
							"",
							"var tree = pm.environment.get('TD_SDN_TREE');",
							"if (tree === undefined) {",
							"    throw new Error('Environment variable \"TD_SDN_TREE\" is undefined. '",
							"            + 'Please run \"Setup\" Request of \"TD_SDN_INIT\" collection.');",
							"}",
							"",
							"var treeIndex = parseInt(tree) - 1;",
							"var companyName = settings.trees[treeIndex][pm.info.iteration];",
							"var companySettings = settings.companies[companyName];",
							"",
							"var pathSuffix;",
							"if (!companySettings.allNetworks) {",
							"    // We will retrieve the ethernet topology only",
							"    pathSuffix = 'ietf-network:networks/network='",
							"        + encodeURIComponent(companySettings.mwNetworkId);",
							"} else {",
							"    // assuming that we have to get all networks",
							"    console.log('We are going to get all networks');",
							"    pathSuffix = 'ietf-network:networks';",
							"}",
							"pm.environment.set('TD_SDN_RESTCONF_PATH', companySettings.restconfPath);",
							"pm.environment.set('TD_SDN_MW_TOPOLOGY_PATH_SUFFIX', pathSuffix);",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "{{TD_SDN_RESTCONF_PATH}}/data/{{TD_SDN_MW_TOPOLOGY_PATH_SUFFIX}}",
					"host": [
						"{{TD_SDN_RESTCONF_PATH}}"
					],
					"path": [
						"data",
						"{{TD_SDN_MW_TOPOLOGY_PATH_SUFFIX}}"
					]
				}
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"id": "ebec5143-15a8-4de0-aa81-2ccd5ea0862c",
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"id": "4ce04dc8-b53f-439d-a610-ccc6f949daf4",
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"protocolProfileBehavior": {}
}