{
	"info": {
		"_postman_id": "42d82362-2586-4fe6-b2d5-8ff7d21f8589",
		"name": "TD_SSD_03",
		"description": "Interoperability Test Description\r\nIdentifier\tTD_ SDN_SNSD_03\r\nTest Objective\tThe Ethernet topology information are requested from a single DC. The received information is compared to a template and checked for compliance.\r\nConfiguration\tCFG_01\r\nReferences\t\r\nApplicability\tMW_8040, MW_8345, MW_ETHSVC\r\n\r\nPre-test conditions\t•\tThe Domain Controller instance is up and running normally\r\n•\tAll the devices are upgraded to correct versions\r\n•\tAll basic configurations are completed (e.g., NE_id, OSPF, PCEP, etc.) \r\n•\tThe Restconf server is serviceable.\r\n\r\nTest\r\nSequence\tStep\tType\tDescription\r\n\t1\tRequest\tSend GET request via Postman to one individual domain controller by executing Collection TD_SDN_SNSD_03 (see E.2.3\t)\r\n\r\n\t2\tValidation\tThe response body should contain information about the Ethernet topology in JSON format as specified in Annex D.",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "TD_SSD_03-Step-1",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "32ba873c-5587-4d73-98b3-a3f00d00c34d",
						"exec": [
							"pm.environment.unset('TD_SDN_RESTCONF_PATH');",
							"pm.environment.unset('TD_SDN_ETH_TOPOLOGY_PATH_SUFFIX');",
							"",
							"pm.test('Response is OK', function() {",
							"    pm.expect(pm.response).to.have.property('code', 200);",
							"});",
							"",
							"var responseJson = pm.response.json();",
							"",
							"var eth = {};",
							"",
							"function parseAllNetworks() {",
							"    var networkList = {};",
							"    // The response body should contain information about the microwave topology and the Ethernet topology in the JSON format as specified in Annex D.1 and D.2.",
							"    var topLevelPropertyName = responseJson.hasOwnProperty('networks')",
							"            ? 'networks' : 'ietf-network:networks';",
							"    pm.test('The response body should contain information about networks', function() {",
							"        pm.expect(responseJson).to.have.property(topLevelPropertyName);",
							"        pm.expect(responseJson[topLevelPropertyName]).to.have.property('network');",
							"        responseJson[topLevelPropertyName].network.forEach(function(item, index) {",
							"            pm.expect(item).to.have.property('network-id');",
							"            pm.expect(networkList).to.not.have.property(item['network-id']); // Make sure each network-id appears only once",
							"            networkList[item['network-id']] = item;",
							"        });",
							"    });",
							"    ",
							"    eth = findEthNetwork(responseJson[topLevelPropertyName].network);",
							"    pm.test('Ethernet topology is present', function() {",
							"        pm.expect(eth).to.not.equal(null);",
							"    });",
							"}",
							"",
							"function findEthNetwork(networks) {",
							"    var len = networks.length;",
							"    var i;",
							"    var net;",
							"    for (i = 0; i < len; ++i) {",
							"        net = networks[i];",
							"        if (net['network-types']",
							"                && net['network-types']['ietf-te-topology:te-topology']",
							"                && net['network-types']['ietf-te-topology:te-topology']['ietf-eth-te-topology:eth-tran-topology']) {",
							"            return net;",
							"        }",
							"    }",
							"    throw new Error('Ethernet network not found');",
							"}",
							"",
							"var settings = pm.environment.get('TD_SDN_SETTINGS');",
							"var companyName = pm.environment.get('TD_SDN_COMPANY');",
							"var companySettings = settings.companies[companyName];",
							"",
							"if (!companySettings.mwNetworkId) {",
							"    throw new Error('Attribute \"network-id\" for mw topology is not known. '",
							"            + 'Please run Request TD_SDN_SNSD_02 first');",
							"}",
							"var mw_network_id = companySettings.mwNetworkId;",
							"if (!companySettings.allNetworks) {",
							"    // We requested only one network. Check if it is the eth network",
							"    var topLevelPropertyName = responseJson.hasOwnProperty('network')",
							"            ? 'network' : 'ietf-network:network';",
							"    pm.expect(responseJson).to.have.property(topLevelPropertyName);",
							"    eth = findEthNetwork(responseJson[topLevelPropertyName]);",
							"} else {",
							"    // We requested all networks. Find mw network",
							"    parseAllNetworks();",
							"}",
							"",
							"// At this point we are sure that 'eth' variable is set",
							"",
							"function compare_tpid(a,b) {",
							"  if (a['tp-id'] < b['tp-id'])",
							"    return -1;",
							"  if (a['tp-id'] > b['tp-id'])",
							"    return 1;",
							"  return 0;",
							"}",
							"",
							"//   ------------------------- ETHERNET ------------------------------",
							"",
							"pm.test('Ethernet topology attributes verification', function() {",
							"    if (!companySettings.allNetworks) {",
							"        // check that found network-id is what it should",
							"        pm.expect(eth).to.have.property('network-id', companySettings.ethNetworkId);",
							"    } else {",
							"        pm.expect(eth).to.have.property('network-id');",
							"    }",
							"    pm.expect(eth).to.have.property('ietf-te-topology:provider-id');",
							"    pm.expect(eth).to.have.property('ietf-te-topology:client-id');",
							"    pm.expect(eth).to.have.property('ietf-te-topology:te-topology-id');",
							"    pm.expect(eth).to.have.property('ietf-te-topology:te');",
							"    pm.expect(eth['ietf-te-topology:te']).to.have.property('name');",
							"});",
							"",
							"if (!eth.hasOwnProperty('network-id')",
							"        || !eth.hasOwnProperty('ietf-te-topology:provider-id')",
							"        || !eth.hasOwnProperty('ietf-te-topology:client-id')",
							"        || !eth.hasOwnProperty('ietf-te-topology:te-topology-id')) {",
							"    throw new Error('One of the identifiers is missing');   ",
							"}",
							"",
							"companySettings.ethProviderId = eth['ietf-te-topology:provider-id'];",
							"companySettings.ethClientId = eth['ietf-te-topology:client-id'];",
							"companySettings.ethTopologyId = eth['ietf-te-topology:te-topology-id'];",
							"pm.environment.set('TD_SDN_SETTINGS', settings);",
							"",
							"var nodeListETH = {};",
							"pm.test('Ethernet topology nodes verification', function() {",
							"    pm.expect(eth).to.have.property('node');",
							"    eth.node.forEach(function(item, index) {",
							"        pm.expect(item).to.have.property('node-id');",
							"        pm.expect(nodeListETH).to.not.have.property(item['node-id']); // Make sure each node-id appears only once",
							"        nodeListETH[item['node-id']] = item;",
							"        var regExpStr = '^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.'",
							"                + '(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.'",
							"                + '(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.'",
							"                + '(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$';",
							"        var regExp = new RegExp(regExpStr);",
							"        pm.expect(regExp.test(item['node-id'])).to.be.true;",
							"        pm.expect(item).to.have.property('ietf-te-topology:te-node-id'); //, item['node-id']);",
							"        pm.expect(item).to.have.property('ietf-te-topology:te');",
							"        pm.expect(item['ietf-te-topology:te']).to.have.property('te-node-attributes');",
							"        pm.expect(item['ietf-te-topology:te']['te-node-attributes']).to.have.property('name')",
							"        //vendor independent",
							"    });",
							"    pm.expect(Object.keys(nodeListETH).length).to.equal(2);",
							"});",
							"",
							"// Ensure nodeListETH have the full nodes information when the above verification partially fails, or the link verification will fail",
							"eth.node.forEach(function(item, index) {",
							"    if(eth.node != null){",
							"        nodeListETH[item['node-id']] = item;",
							"    }",
							"});",
							"",
							"pm.test('Ethernet topology nodes OPER verification', function() {",
							"    for (var key in nodeListETH) {",
							"        pm.expect(nodeListETH[key]['ietf-te-topology:te']).to.have.property('oper-status', 'up');",
							"    }",
							"});",
							"",
							"",
							"pm.test('Ethernet topology termination points verification', function() {",
							"    for (var key in nodeListETH) {",
							"        var node = nodeListETH[key];",
							"        pm.expect(node).to.have.property('ietf-network-topology:termination-point');",
							"        node.tp = {};",
							"        node['ietf-network-topology:termination-point'].sort(compare_tpid);",
							"        node['ietf-network-topology:termination-point'].forEach(function(tp, index) {",
							"            pm.expect(node.tp).to.not.have.property(tp['tp-id']); // Make sure each tp-id appears only once",
							"            node.tp[tp['tp-id']] = tp;",
							"            pm.expect(tp).to.have.property('tp-id'); // Vendor independent, only check existence",
							"            pm.expect(tp).to.have.property('ietf-te-topology:te-tp-id');   // Vendor independent, check only existence",
							"            pm.expect(tp).to.have.property('ietf-te-topology:te');",
							"            // pm.expect(tp['ietf-te-topology:te']).to.have.property('name');",
							"        });",
							"    }",
							"});",
							"",
							"// Ensure nodeListETH have the full tp information when the above verification partially fails, or the link verification will fail",
							"for (var key in nodeListETH) {",
							"    var node = nodeListETH[key];",
							"    node.tp = {};",
							"    node['ietf-network-topology:termination-point'].sort(compare_tpid);",
							"    node['ietf-network-topology:termination-point'].forEach(function(tp, index) {",
							"        node.tp[tp['tp-id']] = tp;",
							"    });",
							"}",
							"",
							"// Verify that access points defined in TD_SDN_INIT exist",
							"var accessPointMap = {};",
							"pm.test('Verify the existence of Service access points', function() {",
							"    for (var key in companySettings.svc) {",
							"        var accessNodeTeId = companySettings.svc[key]['access-node-id'];",
							"        var accessTpTeId1 = companySettings.svc[key]['a-link-aggr-id'];",
							"        var accessTpTeId2 = companySettings.svc[key]['a-link-local-id'];",
							"        for (var nodeId in nodeListETH) {",
							"            var node = nodeListETH[nodeId];",
							"            if (node['ietf-te-topology:te-node-id'] !== accessNodeTeId) {",
							"                continue;",
							"            }",
							"            for (var tpId in node.tp) {",
							"                if ((accessTpTeId1 === node.tp[tpId]['ietf-te-topology:te-tp-id']) || (accessTpTeId2 === node.tp[tpId]['ietf-te-topology:te-tp-id'])) {",
							"                    accessPointMap[nodeId] = tpId;",
							"                }",
							"            }",
							"            break;",
							"        }",
							"    }",
							"    pm.expect(Object.keys(accessPointMap).length).to.equal(2);",
							"});",
							"",
							"// Before running the oper verification for the TPs, we need to separated them in categories.",
							"// At that point we will traverse the Links",
							"",
							"// The following object will act as a Map. The key of each entry will be the",
							"// network node-id and the value will be the nework tp-id of TP that is over mw tp.",
							"var tpsOverMWTopo = {};",
							"// keep links",
							"var linkListETH = {};",
							"// keep the links over the Microwave link",
							"var linksOverMW = {};",
							"// keep the inter-domain links",
							"var interDomainLinks = {};",
							"pm.test('Ethernet topology links verification', function() {",
							"    pm.expect(eth).to.have.property('ietf-network-topology:link');",
							"    eth['ietf-network-topology:link'].forEach(function(item, index) {",
							"        pm.expect(item).to.have.property('link-id');",
							"        pm.expect(linkListETH).to.not.have.property(item['link-id']); // Make sure each link-id appears only once",
							"        linkListETH[item['link-id']] = item;",
							"        ",
							"        pm.expect(item).to.have.property('source');",
							"        pm.expect(item.source).to.have.property('source-node');",
							"        pm.expect(item.source).to.have.property('source-tp');",
							"        ",
							"        pm.expect(item).to.have.property('ietf-te-topology:te');",
							"        pm.expect(item['ietf-te-topology:te']).to.have.property('te-link-attributes');",
							"        pm.expect(item['ietf-te-topology:te']['te-link-attributes']).to.have.property('admin-status');",
							"        pm.expect(item['ietf-te-topology:te']['te-link-attributes']).to.have.property('ietf-eth-te-topology:max-bandwidth');",
							"        pm.expect(item['ietf-te-topology:te']['te-link-attributes']).to.have.property('ietf-eth-te-topology:available-bandwidth');",
							"        // 'destination' may not exist for inter-domain links",
							"        if(item['destination'] != null){",
							"            pm.expect(item).to.have.property('destination');",
							"            pm.expect(item.destination).to.have.property('dest-node');",
							"            pm.expect(item.destination).to.have.property('dest-tp');",
							"            pm.expect(nodeListETH).to.have.property(item.destination['dest-node']);",
							"            pm.expect(nodeListETH[item.destination['dest-node']].tp).to.have.property(item.destination['dest-tp']);",
							"        }",
							"     ",
							"        // 'underlay' may not exist for inner-domain links ",
							"        var underlay = item['ietf-te-topology:te']['te-link-attributes'].underlay;",
							"        if(underlay != null){",
							"            pm.expect(item).to.have.property('destination');",
							"            pm.expect(underlay).to.have.property('primary-path');",
							"            pm.expect(underlay['primary-path']).to.have.property('path-element');",
							"            pm.expect(underlay['primary-path']['path-element'][0]).to.have.property('index');",
							"            pm.expect(underlay['primary-path']['path-element'][0]).to.have.property('path-element-id');",
							"            pm.expect(underlay['primary-path']['path-element'][0]).to.have.property('num-unnum-hop');",
							"            var numUnnumHop = underlay['primary-path']['path-element'][0]['num-unnum-hop'];",
							"            pm.expect(numUnnumHop).to.have.property('hop-type');",
							"            pm.expect(numUnnumHop).to.have.property('node-id');",
							"            pm.expect(numUnnumHop).to.have.property('link-tp-id');",
							"            // check now if the pair node-id/link-tp-id matchs with one from mw tps.",
							"            var teNodeId = numUnnumHop['node-id'];",
							"            var teTpId = numUnnumHop['link-tp-id'];",
							"            if (companySettings.mwLinkPoints[teNodeId] === teTpId) {",
							"                linksOverMW[item['link-id']] = item;",
							"                pm.expect(underlay['primary-path']).to.have.property('network-ref', mw_network_id);",
							"                pm.expect(underlay).to.have.property('enabled',true);",
							"                // Store only the source. The destination will be stored when the corresponding",
							"                // link will be examined.",
							"                tpsOverMWTopo[item.source['source-node']] = item.source['source-tp'];",
							"            }",
							"        } else {",
							"            // Check if it is an inter-domain link",
							"            if (accessPointMap[item.source['source-node']] === item.source['source-tp']) {",
							"                interDomainLinks[item['link-id']] = item;",
							"            }",
							"        }",
							"    });",
							"});",
							"",
							"",
							"pm.test('Ethernet Link over Microwave Link verification', function() {",
							"    pm.expect(Object.keys(linksOverMW).length).to.equal(2);",
							"    var link1 = null;",
							"    var link2 = null;",
							"    var counter = 0;",
							"    for (var linkId in linksOverMW) {",
							"        if (counter++ === 0) {",
							"            link1 = linksOverMW[linkId];",
							"        } else {",
							"            links2 = linksOverMW[linkId];",
							"        }",
							"    }",
							"    pm.expect(link1.source['source-node']).to.equal(links2.destination['dest-node']);",
							"    pm.expect(link1.source['source-tp']).to.equal(links2.destination['dest-tp']);",
							"    pm.expect(link1.destination['dest-node']).to.equal(links2.source['source-node']);",
							"    pm.expect(link1.destination['dest-tp']).to.equal(links2.source['source-tp']);",
							"});",
							"",
							"pm.test('Inter-Domain Links verification', function() {",
							"    for (var key in interDomainLinks) {",
							"        var link = interDomainLinks[key];",
							"        var underlay = link['ietf-te-topology:te']['te-link-attributes'].underlay;",
							"        if (!underlay) {",
							"            continue;",
							"        }",
							"        pm.expect(underlay).to.have.property('enabled', false);",
							"    }",
							"});",
							"",
							"pm.test('Ethernet topology links OPER verification', function() {",
							"    for (var key in linkListETH) {",
							"        var link = linkListETH[key];",
							"        if (linksOverMW[key] || interDomainLinks[key]) {",
							"            pm.expect(link['ietf-te-topology:te']).to.have.property(\"oper-status\", \"up\");",
							"        }",
							"    }",
							"});",
							"",
							"pm.test('Ethernet topology termination points OPER verification', function() {",
							"    for (var key in nodeListETH) {",
							"        var node = nodeListETH[key];",
							"        node['ietf-network-topology:termination-point'].forEach(function(tp, index) {",
							"            // Access TPs and TPs over MW Link should have up oper-status",
							"            if (accessPointMap[node['node-id']] === tp['tp-id']) {",
							"                pm.expect(tp['ietf-te-topology:te']).to.have.property(\"oper-status\", \"up\");",
							"                pm.expect(tp['ietf-te-topology:te']).to.have.property('admin-status', 'up');",
							"                pm.expect(tp).to.have.property('ietf-eth-te-topology:svc');",
							"                pm.expect(tp['ietf-eth-te-topology:svc']).to.have.property('client-facing');",
							"                pm.expect(tp['ietf-eth-te-topology:svc']['client-facing']).be.true;",
							"            } else if (tpsOverMWTopo[node['node-id']] === tp['tp-id']) {",
							"                pm.expect(tp['ietf-te-topology:te']).to.have.property(\"oper-status\", \"up\");",
							"                pm.expect(tp['ietf-te-topology:te']).to.have.property('admin-status', 'up');",
							"                // The following check is not quite correct. An intra-domain link should not",
							"                // have the 'ietf-eth-te-topology:svc' property at all.",
							"                if (tp['ietf-eth-te-topology:svc']) {",
							"                    pm.expect(tp['ietf-eth-te-topology:svc']).to.have.property('client-facing');",
							"                    pm.expect(tp['ietf-eth-te-topology:svc']['client-facing']).be.false;",
							"                }",
							"            }",
							"        });",
							"    }",
							"});",
							""
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"id": "a25d3427-5b87-41ca-a867-83fb54c99b3d",
						"exec": [
							"pm.environment.unset('TD_SDN_RESTCONF_PATH');",
							"pm.environment.unset('TD_SDN_ETH_TOPOLOGY_PATH_SUFFIX');",
							"var settings = pm.environment.get('TD_SDN_SETTINGS');",
							"if (settings === undefined) {",
							"    throw new Error('Environment variable \"TD_SDN_SETTINGS\" is undefined. '",
							"            + 'Please run \"Setup\" Request of \"TD_SDN_INIT\" collection.');",
							"}",
							"var companyName = pm.environment.get('TD_SDN_COMPANY');",
							"if (companyName === undefined) {",
							"    throw new Error('Environment variable \"TD_SDN_COMPANY\" is undefined. '",
							"            + 'Please define it in your environment');",
							"}",
							"var companySettings = settings.companies[companyName];",
							"if (companySettings === undefined) {",
							"    throw new Error('Unknown company \"' + companyName + '\"');",
							"}",
							"",
							"var pathSuffix;",
							"if (!companySettings.allNetworks) {",
							"    // We will retrieve the ethernet topology only",
							"    pathSuffix = 'ietf-network:networks/network=' + encodeURIComponent(companySettings.ethNetworkId);",
							"} else {",
							"    // assuming that we have to get all networks",
							"    console.log('We are going to get all networks');",
							"    // check if \"TD_SDN_SNSD_02-Step-1\" has already be run'",
							"    if (!companySettings.mwNetworkId) {",
							"        throw new Error('Property \"mwNetworkId\" is unknown. Please run \"TD_SDN_SNSD_02-Step-1\" first');",
							"    }",
							"    pathSuffix = 'ietf-network:networks';",
							"}",
							"pm.environment.set('TD_SDN_RESTCONF_PATH', companySettings.restconfPath);",
							"pm.environment.set('TD_SDN_ETH_TOPOLOGY_PATH_SUFFIX', pathSuffix);",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "{{TD_SDN_RESTCONF_PATH}}/data/{{TD_SDN_ETH_TOPOLOGY_PATH_SUFFIX}}",
					"host": [
						"{{TD_SDN_RESTCONF_PATH}}"
					],
					"path": [
						"data",
						"{{TD_SDN_ETH_TOPOLOGY_PATH_SUFFIX}}"
					]
				}
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"id": "9c347ff8-2e3a-4361-8303-0de8c594bc6d",
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"id": "9f7c771c-cf53-4315-95b2-da72da59c2aa",
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"protocolProfileBehavior": {}
}